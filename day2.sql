drop table if exists temp_input;
create temp table temp_input as
select 
'DLUUULUDLRDDLLLUDULLULLRUURURLUULDUUUDLDDRUDLUULLRLDDURURDDRDRDLDURRURDLDUURULDDULDRDDLDLDLRDRUURLDLUDDDURULRLLLLRLULLUDRDLDUURDURULULULRLULLLULURLRDRDDDDDDDLRLULUULLULURLLDLRLUDULLDLLURUDDLDULDLULDDRLRLRDDLRURLLLURRLDURRDLLUUUUDRURUULRLDRRULLRUDLDRLUDRDRDRRDDURURRDRDRUDURDLUDRUDLRRULDLRDDRURDDUUDLDRDULDDRRURLLULRDRURLRLDLLLUULUUDLUDLDRRRRDUURULDUDUDRLDLLULLLRDDDDDLRDDLLUULLRRRDURLRURDURURLUDRRLRURDRDRRRRULUDLDRDULULRUDULLLUDRRLRLURDDURULDUUDULLURUULRDRDULRUUUDURURDDRRUDURRLRDRULRUUU
LDRURRUUUULDRDDDLLULDRUDDRLLDLDRDLRUDDDLDDULULULLRULDUDRRDLRUURURDRURURDLLRUURDUUDRLDURDRDLRRURURDUUUURUURRLLLDRDUURRRRURULUUUDLUDDRUURRLDULRDULRRRRUDURRLURULRURRDRDLLDRRDUDRDURLDDRURULDRURUDDURDLLLUURRLDRULLURDRDRLDRRURRLRRRDDDDLUDLUDLLDURDURRDUDDLUDLRULRRRDRDDLUDRDURDRDDUURDULRRULDLDLLUDRDDUDUULUDURDRLDURLRRDLDDLURUDRLDUURLLRLUDLLRLDDUDLLLRRRLDLUULLUDRUUDRLDUUUDUURLRDDDDRRDRLDDRDLUDRULDDDRDUULLUUUUULDULRLLLRLLDULRDUDDRDDLRRLRDDULLDURRRURDDUDUDDRLURRLUUUULLDRDULUUDRDULDLLUDLURDLLURRDLUULURRULRLURRRRRUURDDURLRLLDDLRRDUUURDRDUDRDDDLLDDRDRRRLURRDUULULULULRRURDDLDDLLLRUDDDDDDLLLRDULURULLRLRDRR
DDRLLLDLRRURRDLDDRUURRURRLRRRRUURUURDLURRRDDLRUDRURLUURLLRRLRLURLURURDULLLLDLRURULUUDURRLULRDRDRRDDLLULRLUDLUUUDRLLRRURRLDULDDLRRLUUUUDDLRLDRLRRDRDLDDURDDRDDLDLURLRRRDDUDLLRLRLURRRRULLULLLLDRLDULDLLDULRLDRDLDDRRDDDDRUDRLLURULRLDDLLRRURURDDRLLLULLULDDRDLDDDLRLLDRLDRUURRULURDDRLULLDUURRULURUUDULLRUDDRRLLDLLRDRUDDDDLLLDDDLLUUUULLDUUURULRUUDUUUDDLDURLDRDRRLLUDULDLUDRLLLDRRRULUUDDURUDRLUDDRRLLDUDUURDDRURLUURDURURURRUUDUDDLLLDRRRURURRURDLRULLDUDRLRLLRUDRUDLR
RRRDRLRURLRRLUURDRLDUURURLRDRRUDLLUUDURULLUURDLLDRRLURRUDUUDRRURLRRDULLDDLRRRUDUUDUUDLDDDLUUDLDULDDULLDUUUUDDUUDUDULLDDURRDLRRUDUDLRDUULDULRURRRLDLLURUDLDDDRRLRDURDLRRLLLRUDLUDRLLLRLLRRURUDLUDURLDRLRUDLRUULDRULLRLDRDRRLDDDURRRUDDDUDRRDRLDDRDRLLRLLRDLRDUDURURRLLULRDRLRDDRUULRDDRLULDLULURDLRUDRRDDDLDULULRDDRUDRLRDDRLDRDDRRRDUURDRLLDDUULRLLLULLDRDUDRRLUUURLDULUUURULLRLUDLDDLRRDLLRDDLRDRUUDURDDLLLDUUULUUDLULDUDULDRLRUDDURLDDRRRDLURRLLRRRUDDLDDRURDUULRUURDRRURURRRUUDUDULUDLUDLLLUUUULRLLRRRRDUDRRDRUDURLUDDLDRDLDDRULLRRULDURUL
DLLLRDDURDULRRLULURRDULDLUDLURDDURRLLRRLLULRDLDRDULRLLRDRUUULURRRLLRLDDDRDRRULDRRLLLLDLUULRRRURDDRULLULDDDLULRLRRRUDRURULUDDRULDUDRLDRRLURULRUULLLRUURDURLLULUURUULUUDLUDLRRULLLRRLRURDRRURDRULRURRUDUDDDRDDULDLURUDRDURLDLDLUDURLLRUULLURLDDDURDULRLUUUDLLRRLLUURRDUUDUUDUURURDRRRRRRRRRUDULDLULURUDUURDDULDUDDRDDRDRLRUUUUDLDLRDUURRLRUUDDDDURLRRULURDUUDLUUDUUURUUDRURDRDDDDULRLLRURLRLRDDLRUULLULULRRURURDDUULRDRRDRDLRDRRLDUDDULLDRUDDRRRD'::text as inputs
;


drop table if exists inst;
create temp table inst as 
select row_number() over () as id
	,instruction
from(
select unnest(string_to_array(inputs,'
')) as instruction
from temp_input
)t
;



create function jfoster1.button(text, int default 5) returns integer as $$
	select 
		case 
		when $1 = 'R' and $2 not in (3,6,9) then $2 + 1
		when $1 = 'L' and $2 not in (1,4,7) then $2 - 1
		when $1 = 'U' and $2 not in (1,2,3) then $2 - 3
		When $1 = 'D' and $2 not in (7,8,9) then $2 + 3
		else $2
		end;
	$$
	Language SQL;

select unnest(regexp_split_to_array(instruction,'')) as button
from inst
where id = 1
;

drop table if exists inst1;
create temp table inst1 as
select id,row_number() over() as subid,button,5 as cur, 1 as counter
from(
	select id,unnest(regexp_split_to_array(instruction,'')) as button
	from inst
-- 	where id = 1
	)t
;

with recursive butt(id,subid,button,cur,counter) as(
select id, subid, button
	,jfoster1.button(button) as cur
	,1 as counter
from inst1
where subid = 1

union all

select id, subid, button
	,jfoster1.button(button,cur) as cur
	,counter + 1 as counter
from(
	select i.id,i.subid,i.button, b.cur,b.counter
		from butt b
		inner join inst1 i
-- 			on i.id = b.id
-- 			and i.subid = b.subid + 1
			on i.subid = b.subid + 1
-- 		where id = 1
		)t
where subid = 1 + counter
)

select * from butt
;





create function jfoster1.advanced_button(text, int default 5) returns integer as $$
	select 
		case 
		when $1 = 'R' and $2 not in (1,4,9,12,13) then $2 + 1
		when $1 = 'L' and $2 not in (1,2,5,10,13) then $2 - 1
		when $1 = 'U' and $2 in (3,13) then $2 - 2
		when $1 = 'U' and $2 in (6,7,8,10,11,12) then $2 - 4
		When $1 = 'D' and $2 in (1,11) then $2 + 2
		When $1 = 'D' and $2 in (2,3,4,6,7,8) then $2 + 4
		else $2
		end;
	$$
	Language SQL;





drop table if exists inst1;
create temp table inst1 as
select id,row_number() over() as subid,button,5 as cur, 1 as counter
from(
	select id,unnest(regexp_split_to_array(instruction,'')) as button
	from inst
-- 	where id = 5
	)t
;

with recursive butt(id,subid,button,cur,counter) as(
select id, subid, button
	,jfoster1.advanced_button(button) as cur
	,1 as counter
from inst1
where subid = 1

union all

select id, subid, button
	,jfoster1.advanced_button(button,cur) as cur
	,counter + 1 as counter
from(
	select i.id,i.subid,i.button, b.cur,b.counter
		from butt b
		inner join inst1 i
-- 			on i.id = b.id
			on i.subid = b.subid + 1
-- 		where id = 1
		)t
where subid = 1 + counter
)

select * from butt
;
